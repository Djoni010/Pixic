/*
Copyright (C) 2022 Серый MLGamer <Seriy-MLGamer@yandex.ru>

This file is part of Pixic.
Pixic is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
Pixic is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with Pixic. If not, see <https://www.gnu.org/licenses/>.
*/

/**
 * @file program/translator/parser/tokens/statements/Fn.pixi
 *
 * Dependencies.
 * program/translator/parser/tokens/statements/Statement.pixi
 * program/translator/parser/tokens/expressions/Variable.pixi
 * program/translator/parser/tokens/statements/Block.pixi
 */

fn Fn_new($text, $positions)
{
	$self=Statement_new($text, $positions)
	$self.f=Fn

	promise_position($positions)
	$test=new(get_size(KEYWORDS[KEYWORD_fn]), 1, INT8)
	clean($test)
	copy($test, $text.data, 0, Stack_get($positions).index)
	if strstr($test, KEYWORDS[KEYWORD_fn])
	{
		remove($test)
		reject_position($positions)

		remove($self)
		ret(-1)
	}
	Stack_get($positions).index+get_size($test)
	remove($test)
	promise_position($positions)
	if is_symbolic(get_char($text, $positions))
	{
		reject_position($positions)
		reject_position($positions)

		remove($self)
		ret(-2)
	}
	reject_position($positions)
	if skip_spaces($text, $positions)
	{
		Stack_get($positions).line-1
		syntax_error_expected_function_identifier($text, $positions)
	}
	promise_position($positions)
	$token=Variable_new($text, $positions)
	if $token<0
	{
		syntax_error_expected_function_identifier($text, $positions)
	}
	if $text.data[$token.name_start]=='$'
	{
		reject_position($positions)
		syntax_error_expected_function_identifier($text, $positions)
	}
	resolve_position($positions)
	$self.identifier=$token
	if skip_spaces($text, $positions)
	{
		Stack_get($positions).line-1
		syntax_error_expected($text, $positions, '(')
	}
	promise_position($positions)
	if get_char($text, $positions)!='('
	{
		reject_position($positions)
		syntax_error_expected($text, $positions, '(')
	}
	resolve_position($positions)
	if skip_spaces($text, $positions)
	{
		Stack_get($positions).line-1
		syntax_error_expected($text, $positions, ')')
	}
	$arguments=Stack_new(INT)
	$token=Variable_new($text, $positions)
	if $token<0
	{
		promise_position($positions)
		if get_char($text, $positions)!=')'
		{
			reject_position($positions)
			syntax_error_expected($text, $positions, ')')
		}
	}
	else
	{
		while 1
		{
			if skip_spaces($text, $positions)
			{
				Stack_get($positions).line-1
				syntax_error_expected($text, $positions, ')')
			}
			Stack_push($arguments, $token)
			promise_position($positions)
			$token=get_char($text, $positions)
			if $token==')'
			{
				break
			}
			if $token==','
			{
				resolve_position($positions)
				if skip_spaces($text, $positions)
				{
					Stack_get($positions).line-1
					syntax_error_expected_argument($text, $positions)
				}
				$token=Variable_new($text, $positions)
				if $token<0
				{
					syntax_error_expected_argument($text, $positions)
				}
			}
			else
			{
				reject_position($positions)
				syntax_error_expected($text, $positions, ')')
			}
		}
	}
	resolve_position($positions)
	$self.arguments=$arguments
	$self.last_line=Stack_get($positions).line+1
	if skip_spaces($text, $positions)
	{
		Stack_get($positions).line-1
		syntax_error_expected($text, $positions, '{')
	}
	$token=Block_new($text, $positions)
	if $token<0
	{
		syntax_error_expected($text, $positions, '{')
	}
	$self.body=$token
	resolve_position($positions)

	ret($self)
}
Fn=new()
Fn.remove=Fn_remove
Fn.show=Fn_show
fn Fn_remove($self)
{
	Variable_remove($self.identifier)
	$arguments=$self.arguments
	while $arguments.pointer>=0
	{
		$argument=Stack_pop($arguments)
		Variable_remove($argument)
	}
	remove($arguments)
	Block_remove($self.body)

	remove($self)
}
fn Fn_show($self)
{
	begin_object()
		indent() logf("\"type\": \"Fn\"") next_property()
		indent() Statement_show($self) next_property()
		indent()
			$token=$self.identifier
			$text=$token.text
			$name=new($token.name_length, 1, INT8)
			copy($name, $text, 0, $token.name_start)
			logf("\"identifier\": \"%s\"", $name)
			next_property()
		indent() logf("\"arguments\": ")
			$arguments=$self.arguments
			$arguments_count=$arguments.pointer+1
			if $arguments_count
			{
				begin_array()
					$a=0 while 1
					{
						$token=$arguments[$a]
						indent()
							resize($name, $token.name_length)
							copy($name, $text, 0, $token.name_start)
							logf("\"%s\"", $name)
						if $a!=$arguments_count-1
						{
								next_property()
							$a+1
						}
						else
						{
							break
						}
					}
				end_array()
			}
			else
			{
				logf("null")
			}
			remove($name)
			next_property()
		indent() logf("\"body\": ") Block_show($self.body)
	end_object()
}