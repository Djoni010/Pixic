/*
Copyright (C) 2022 Серый MLGamer <Seriy-MLGamer@yandex.ru>

This file is part of Pixic.
Pixic is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
Pixic is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with Pixic. If not, see <https://www.gnu.org/licenses/>.
*/

/**
 * @file Number.pixi
 *
 * Dependencies.
 * program/translator/parser/parsing functions.pixi
 * program/info/syntax errors.pixi
 * program/translator/parser/tokens/show.pixi
 */

NUMBER_int=  0
NUMBER_bin=  1
NUMBER_hex=  2
NUMBER_color=3
NUMBER_float=4

fn Number_new($text, $positions)
{
	$self=new()
	$self.f=Number

	promise_position($positions)
	$self.text=$text.data
	if get_char($text, $positions)!='-'
	{
		$self.minus=0
		reject_position($positions)
		promise_position($positions)
	}
	else
	{
		if skip_spaces($text, $positions)
		{
			reject_position($positions)

			remove($self)
			ret(-1)
		}
		$self.minus=1
	}
	$self.value_start=Stack_get($positions).index
	promise_position($positions)
	$state=0
	while 1
	{
		$state=Number_new_jump0[$state](get_char($text, $positions), $self, $positions)
		if $state<0
		{
			break
		}
		else
		{
			resolve_position($positions)
			promise_position($positions)
		}
	}
	reject_position($positions)
	if $state==-1
	{
		$self.value_length=Stack_get($positions).index-$self.value_start
		resolve_position($positions)

		ret($self)
	}
	if $state==-2
	{
		reject_position($positions)

		remove($self)
		ret(-2)
	}
	if $state==-3
	{
		syntax_error_invalid_number($text, $positions)
	}
}
Number_new_jump0=new(13, 1, INT)
Number_new_jump0[0]=
{
	if $1=='#'
	{
		$2.type=NUMBER_color
		$2.value_start=Stack_get($3).index
		ret(1)
	}
	if $1=='.'
	{
		$2.type=NUMBER_float
		ret(2)
	}
	if $1=='0'
	{
		ret(3)
	}
	if $1>='1'&&$1<='9'
	{
		$2.type=NUMBER_int
		ret(4)
	}
	ret(-2)
}
Number_new_jump0[1]=
{
	if $1>='0'&&$1<='9'||($1>='A'&&$1<='F')||($1>='a'&&$1<='f')
	{
		ret(5)
	}
	ret(-3)
}
Number_new_jump0[2]=
{
	if $1>='0'&&$1<='9'
	{
		ret(6)
	}
	if $2.minus
	{
		ret(-3)
	}
	ret(-2)
}
Number_new_jump0[3]=
{
	if $1=='.'
	{
		$2.type=NUMBER_float
		ret(6)
	}
	if $1=='B'||$1=='b'
	{
		$2.type=NUMBER_bin
		$2.value_start=Stack_get($3).index
		ret(7)
	}
	if $1=='X'||$1=='x'
	{
		$2.type=NUMBER_hex
		$2.value_start=Stack_get($3).index
		ret(1)
	}
	if $1>='0'&&$1<='9'
	{
		$2.type=NUMBER_int
		ret(4)
	}
	if is_symbolic($1)
	{
		ret(-3)
	}
	$2.type=NUMBER_int
	ret(-1)
}
Number_new_jump0[4]=
{
	if $1=='.'
	{
		$2.type=NUMBER_float
		ret(6)
	}
	if $1>='0'&&$1<='9'
	{
		ret(4)
	}
	if is_symbolic($1)
	{
		ret(-3)
	}
	ret(-1)
}
Number_new_jump0[5]=
{
	if $1>='0'&&$1<='9'||($1>='A'&&$1<='F')||($1>='a'&&$1<='f')
	{
		ret(5)
	}
	if is_symbolic($1)
	{
		ret(-3)
	}
	ret(-1)
}
Number_new_jump0[6]=
{
	if $1>='0'&&$1<='9'
	{
		ret(6)
	}
	if $1=='E'||$1=='e'
	{
		ret(8)
	}
	if $1=='F'||$1=='f'
	{
		ret(9)
	}
	if is_symbolic($1)
	{
		ret(-3)
	}
	ret(-1)
}
Number_new_jump0[7]=
{
	if $1=='0'||$1=='1'
	{
		ret(10)
	}
	ret(-3)
}
Number_new_jump0[8]=
{
	if $1=='+'||$1=='-'
	{
		ret(11)
	}
	if $1>='0'&&$1<='9'
	{
		ret(12)
	}
	if is_symbolic($1)
	{
		ret(-3)
	}
	ret(-1)
}
Number_new_jump0[9]=
{
	if is_symbolic($1)
	{
		ret(-3)
	}
	ret(-1)
}
Number_new_jump0[10]=
{
	if $1=='0'||$1=='1'
	{
		ret(10)
	}
	if is_symbolic($1)
	{
		ret(-3)
	}
	ret(-1)
}
Number_new_jump0[11]=
{
	if $1>='0'&&$1<='9'
	{
		ret(12)
	}
	ret(-3)
}
Number_new_jump0[12]=
{
	if $1>='0'&&$1<='9'
	{
		ret(12)
	}
	if $1=='F'||$1=='f'
	{
		ret(9)
	}
	if is_symbolic($1)
	{
		ret(-3)
	}
	ret(-1)
}
Number=new()
Number.remove=Number_remove
Number.show=Number_show
fn Number_remove($self)
{
	remove($self)
}
fn Number_show($self)
{
	begin_object()
		indent() logf("\"type\": \"Number\"") next_property()
		$type=$self.type
		indent() logf("\"number type\": \"%s\"", Number_show_table[$type]) next_property()
		indent()
			if $type==NUMBER_int||$type==NUMBER_float
			{
				$value=new($self.value_length, 1, INT8)
				copy($value, $self.text, 0, $self.value_start)
			}
			else{if $type==NUMBER_bin
			{
				$value=new($self.value_length+2, 1, INT8)
				$value[0]='0'
				$value[1]='b'
				copy($value, $self.text, 2, $self.value_start)
			}
			else{if $type==NUMBER_hex
			{
				$value=new($self.value_length+2, 1, INT8)
				$value[0]='0'
				$value[1]='x'
				copy($value, $self.text, 2, $self.value_start)
			}
			else{if $type==NUMBER_color
			{
				$value=new($self.value_length+1, 1, INT8)
				$value[0]='#'
				copy($value, $self.text, 1, $self.value_start)
			}}}}
			if $self.minus
			{
				logf("\"value\": \"-%s\"", $value)
			}
			else
			{
				logf("\"value\": \"%s\"", $value)
			}
			remove($value)
	end_object()
}
Number_show_table=new(5, 1, INT)
Number_show_table[NUMBER_int]=  "integer"
Number_show_table[NUMBER_bin]=  "binary"
Number_show_table[NUMBER_hex]=  "hexadecimal"
Number_show_table[NUMBER_color]="color"
Number_show_table[NUMBER_float]="float"